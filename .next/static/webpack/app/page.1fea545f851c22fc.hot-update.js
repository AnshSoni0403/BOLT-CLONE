"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/globe-visualization.tsx":
/*!************************************************!*\
  !*** ./src/components/globe-visualization.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GlobeVisualization)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction GlobeVisualization() {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isInteracting, setIsInteracting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const interactionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        isMouseDown: false,\n        lastMouseX: 0,\n        lastMouseY: 0,\n        rotationSpeedX: 0.003,\n        rotationSpeedY: 0.001,\n        rotationX: 0,\n        rotationY: 0,\n        zoom: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"GlobeVisualization.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) return;\n            // Function to set canvas dimensions with higher resolution for retina displays\n            const setCanvasDimensions = {\n                \"GlobeVisualization.useEffect.setCanvasDimensions\": ()=>{\n                    const container = canvas.parentElement;\n                    if (container) {\n                        const devicePixelRatio = window.devicePixelRatio || 1;\n                        canvas.width = container.clientWidth * devicePixelRatio;\n                        canvas.height = container.clientHeight * devicePixelRatio;\n                        canvas.style.width = `${container.clientWidth}px`;\n                        canvas.style.height = `${container.clientHeight}px`;\n                        ctx.scale(devicePixelRatio, devicePixelRatio);\n                    }\n                }\n            }[\"GlobeVisualization.useEffect.setCanvasDimensions\"];\n            setCanvasDimensions();\n            window.addEventListener(\"resize\", setCanvasDimensions);\n            // Define connection points (major cities)\n            const points = [\n                {\n                    lat: 40.7128,\n                    lng: -74.006,\n                    name: \"New York\",\n                    size: 1.2\n                },\n                {\n                    lat: 51.5074,\n                    lng: -0.1278,\n                    name: \"London\",\n                    size: 1.2\n                },\n                {\n                    lat: 35.6762,\n                    lng: 139.6503,\n                    name: \"Tokyo\",\n                    size: 1.2\n                },\n                {\n                    lat: -33.8688,\n                    lng: 151.2093,\n                    name: \"Sydney\",\n                    size: 1\n                },\n                {\n                    lat: 37.7749,\n                    lng: -122.4194,\n                    name: \"San Francisco\",\n                    size: 1\n                },\n                {\n                    lat: 19.076,\n                    lng: 72.8777,\n                    name: \"Mumbai\",\n                    size: 1\n                },\n                {\n                    lat: -23.5505,\n                    lng: -46.6333,\n                    name: \"SÃ£o Paulo\",\n                    size: 1\n                },\n                {\n                    lat: 48.8566,\n                    lng: 2.3522,\n                    name: \"Paris\",\n                    size: 1\n                },\n                {\n                    lat: 55.7558,\n                    lng: 37.6173,\n                    name: \"Moscow\",\n                    size: 1\n                },\n                {\n                    lat: 31.2304,\n                    lng: 121.4737,\n                    name: \"Shanghai\",\n                    size: 1.1\n                },\n                {\n                    lat: -6.2088,\n                    lng: 106.8456,\n                    name: \"Jakarta\",\n                    size: 1\n                },\n                {\n                    lat: 28.6139,\n                    lng: 77.209,\n                    name: \"New Delhi\",\n                    size: 1\n                },\n                {\n                    lat: 25.2048,\n                    lng: 55.2708,\n                    name: \"Dubai\",\n                    size: 1\n                },\n                {\n                    lat: -34.6037,\n                    lng: -58.3816,\n                    name: \"Buenos Aires\",\n                    size: 1\n                },\n                {\n                    lat: 30.0444,\n                    lng: 31.2357,\n                    name: \"Cairo\",\n                    size: 1\n                },\n                {\n                    lat: 59.3293,\n                    lng: 18.0686,\n                    name: \"Stockholm\",\n                    size: 0.9\n                },\n                {\n                    lat: -1.2921,\n                    lng: 36.8219,\n                    name: \"Nairobi\",\n                    size: 0.9\n                },\n                {\n                    lat: 41.0082,\n                    lng: 28.9784,\n                    name: \"Istanbul\",\n                    size: 1\n                },\n                {\n                    lat: 1.3521,\n                    lng: 103.8198,\n                    name: \"Singapore\",\n                    size: 1\n                },\n                {\n                    lat: -26.2041,\n                    lng: 28.0473,\n                    name: \"Johannesburg\",\n                    size: 0.9\n                }\n            ];\n            // Create connection pairs (not all cities connect to all others)\n            const connections = [\n                [\n                    0,\n                    1\n                ],\n                [\n                    0,\n                    4\n                ],\n                [\n                    0,\n                    6\n                ],\n                [\n                    0,\n                    7\n                ],\n                [\n                    0,\n                    9\n                ],\n                [\n                    0,\n                    13\n                ],\n                [\n                    1,\n                    7\n                ],\n                [\n                    1,\n                    8\n                ],\n                [\n                    1,\n                    11\n                ],\n                [\n                    1,\n                    12\n                ],\n                [\n                    1,\n                    17\n                ],\n                [\n                    2,\n                    4\n                ],\n                [\n                    2,\n                    9\n                ],\n                [\n                    2,\n                    10\n                ],\n                [\n                    2,\n                    18\n                ],\n                [\n                    3,\n                    6\n                ],\n                [\n                    3,\n                    10\n                ],\n                [\n                    3,\n                    18\n                ],\n                [\n                    3,\n                    19\n                ],\n                [\n                    4,\n                    9\n                ],\n                [\n                    4,\n                    18\n                ],\n                [\n                    5,\n                    11\n                ],\n                [\n                    5,\n                    12\n                ],\n                [\n                    5,\n                    18\n                ],\n                [\n                    6,\n                    13\n                ],\n                [\n                    6,\n                    19\n                ],\n                [\n                    7,\n                    8\n                ],\n                [\n                    7,\n                    17\n                ],\n                [\n                    8,\n                    11\n                ],\n                [\n                    8,\n                    17\n                ],\n                [\n                    9,\n                    10\n                ],\n                [\n                    9,\n                    11\n                ],\n                [\n                    10,\n                    18\n                ],\n                [\n                    11,\n                    12\n                ],\n                [\n                    12,\n                    16\n                ],\n                [\n                    12,\n                    19\n                ],\n                [\n                    14,\n                    16\n                ],\n                [\n                    14,\n                    17\n                ],\n                [\n                    14,\n                    19\n                ],\n                [\n                    15,\n                    17\n                ],\n                [\n                    16,\n                    19\n                ]\n            ];\n            // Animation properties\n            const animationProps = {\n                time: 0,\n                pulseSpeed: 0.02,\n                connectionAnimations: connections.map({\n                    \"GlobeVisualization.useEffect\": ()=>({\n                            progress: Math.random(),\n                            speed: 0.002 + Math.random() * 0.003\n                        })\n                }[\"GlobeVisualization.useEffect\"]),\n                hoverPoint: null,\n                particleTime: 0\n            };\n            // Generate random particles around the globe\n            const numParticles = 150;\n            const particles = Array.from({\n                length: numParticles\n            }, {\n                \"GlobeVisualization.useEffect.particles\": ()=>({\n                        lat: Math.random() * 180 - 90,\n                        lng: Math.random() * 360 - 180,\n                        size: 0.2 + Math.random() * 0.5,\n                        speed: 0.1 + Math.random() * 0.3,\n                        offset: Math.random() * Math.PI * 2\n                    })\n            }[\"GlobeVisualization.useEffect.particles\"]);\n            // Function to convert latitude and longitude into 3D coordinates on the globe\n            const latLngTo3D = {\n                \"GlobeVisualization.useEffect.latLngTo3D\": (lat, lng, radius)=>{\n                    const phi = (90 - lat) * (Math.PI / 180);\n                    const theta = (lng + 180) * (Math.PI / 180);\n                    const x = -radius * Math.sin(phi) * Math.cos(theta);\n                    const y = radius * Math.cos(phi);\n                    const z = radius * Math.sin(phi) * Math.sin(theta);\n                    return {\n                        x,\n                        y,\n                        z\n                    };\n                }\n            }[\"GlobeVisualization.useEffect.latLngTo3D\"];\n            // Function to rotate a 3D point around the Y and X axes\n            const rotatePoint = {\n                \"GlobeVisualization.useEffect.rotatePoint\": (point, rotationX, rotationY)=>{\n                    // Rotate around Y axis\n                    const cosY = Math.cos(rotationY);\n                    const sinY = Math.sin(rotationY);\n                    const x1 = point.x * cosY - point.z * sinY;\n                    const z1 = point.z * cosY + point.x * sinY;\n                    // Rotate around X axis\n                    const cosX = Math.cos(rotationX);\n                    const sinX = Math.sin(rotationX);\n                    const y2 = point.y * cosX - z1 * sinX;\n                    const z2 = z1 * cosX + point.y * sinX;\n                    return {\n                        x: x1,\n                        y: y2,\n                        z: z2\n                    };\n                }\n            }[\"GlobeVisualization.useEffect.rotatePoint\"];\n            // Function to project a 3D point onto the 2D canvas\n            const project = {\n                \"GlobeVisualization.useEffect.project\": (point, centerX, centerY, zoom)=>{\n                    // Simple perspective projection\n                    const fov = 300;\n                    const viewZ = fov + point.z * zoom;\n                    const scale = fov / Math.max(1, viewZ);\n                    const x = centerX + point.x * scale * zoom;\n                    const y = centerY + point.y * scale * zoom;\n                    return {\n                        x,\n                        y,\n                        scale,\n                        depth: viewZ\n                    };\n                }\n            }[\"GlobeVisualization.useEffect.project\"];\n            // Function to draw a glowing circle\n            const drawGlowingCircle = {\n                \"GlobeVisualization.useEffect.drawGlowingCircle\": (x, y, radius, color, glowColor, glowSize)=>{\n                    // Draw outer glow\n                    const gradient = ctx.createRadialGradient(x, y, radius, x, y, radius + glowSize);\n                    gradient.addColorStop(0, glowColor);\n                    gradient.addColorStop(1, \"rgba(0, 0, 0, 0)\");\n                    ctx.fillStyle = gradient;\n                    ctx.beginPath();\n                    ctx.arc(x, y, radius + glowSize, 0, Math.PI * 2);\n                    ctx.fill();\n                    // Draw inner circle\n                    ctx.fillStyle = color;\n                    ctx.beginPath();\n                    ctx.arc(x, y, radius, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n            }[\"GlobeVisualization.useEffect.drawGlowingCircle\"];\n            // Function to draw the globe and its grid, points, and connections\n            const drawGlobe = {\n                \"GlobeVisualization.useEffect.drawGlobe\": (timestamp)=>{\n                    if (!ctx || !canvas) return;\n                    const container = canvas.parentElement;\n                    if (!container) return;\n                    const width = container.clientWidth;\n                    const height = container.clientHeight;\n                    ctx.clearRect(0, 0, width, height);\n                    const centerX = width / 2;\n                    const centerY = height / 2;\n                    const baseRadius = Math.min(width, height) * 0.35;\n                    const radius = baseRadius * interactionRef.current.zoom;\n                    // Update rotation based on interaction or auto-rotation\n                    if (!interactionRef.current.isMouseDown) {\n                        interactionRef.current.rotationY += interactionRef.current.rotationSpeedY;\n                        interactionRef.current.rotationX += interactionRef.current.rotationSpeedX;\n                    }\n                    // Update animation time\n                    animationProps.time += 0.01;\n                    animationProps.particleTime += 0.005;\n                    // Draw the globe background (with gradient)\n                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 1.2);\n                    gradient.addColorStop(0, \"rgba(30, 64, 175, 0.2)\");\n                    gradient.addColorStop(0.5, \"rgba(30, 64, 175, 0.15)\");\n                    gradient.addColorStop(1, \"rgba(30, 64, 175, 0)\");\n                    ctx.beginPath();\n                    ctx.arc(centerX, centerY, radius * 1.2, 0, Math.PI * 2);\n                    ctx.fillStyle = gradient;\n                    ctx.fill();\n                    // Draw the globe outer glow\n                    const glowGradient = ctx.createRadialGradient(centerX, centerY, radius * 0.9, centerX, centerY, radius * 1.3);\n                    glowGradient.addColorStop(0, \"rgba(59, 130, 246, 0.2)\");\n                    glowGradient.addColorStop(1, \"rgba(59, 130, 246, 0)\");\n                    ctx.beginPath();\n                    ctx.arc(centerX, centerY, radius * 1.3, 0, Math.PI * 2);\n                    ctx.fillStyle = glowGradient;\n                    ctx.fill();\n                    // Draw the globe (circle with gradient)\n                    const sphereGradient = ctx.createRadialGradient(centerX - radius * 0.3, centerY - radius * 0.3, 0, centerX, centerY, radius);\n                    sphereGradient.addColorStop(0, \"rgba(59, 130, 246, 0.4)\");\n                    sphereGradient.addColorStop(0.7, \"rgba(30, 64, 175, 0.3)\");\n                    sphereGradient.addColorStop(1, \"rgba(30, 64, 175, 0.2)\");\n                    ctx.beginPath();\n                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n                    ctx.fillStyle = sphereGradient;\n                    ctx.fill();\n                    ctx.beginPath();\n                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n                    ctx.strokeStyle = \"rgba(59, 130, 246, 0.6)\";\n                    ctx.lineWidth = 2;\n                    ctx.stroke();\n                    // Store all projected points for later use\n                    const projectedPoints = [];\n                    // Calculate and store all projected points\n                    points.forEach({\n                        \"GlobeVisualization.useEffect.drawGlobe\": (point, index)=>{\n                            const { x, y, z } = latLngTo3D(point.lat, point.lng, radius);\n                            const rotated = rotatePoint({\n                                x,\n                                y,\n                                z\n                            }, interactionRef.current.rotationX, interactionRef.current.rotationY);\n                            const projected = project(rotated, centerX, centerY, interactionRef.current.zoom);\n                            projectedPoints.push({\n                                x: rotated.x,\n                                y: rotated.y,\n                                z: rotated.z,\n                                projX: projected.x,\n                                projY: projected.y,\n                                scale: projected.scale,\n                                depth: projected.depth,\n                                index,\n                                size: point.size || 1\n                            });\n                        }\n                    }[\"GlobeVisualization.useEffect.drawGlobe\"]);\n                    // Sort points by z-depth for proper rendering\n                    projectedPoints.sort({\n                        \"GlobeVisualization.useEffect.drawGlobe\": (a, b)=>a.z - b.z\n                    }[\"GlobeVisualization.useEffect.drawGlobe\"]);\n                    // Draw grid lines (latitude and longitude)\n                    const numLatLines = 10;\n                    const numLngLines = 18;\n                    // Draw longitude lines (vertical)\n                    for(let i = 0; i < numLngLines; i++){\n                        const lng = i / numLngLines * 360 - 180;\n                        const points = [];\n                        for(let lat = -90; lat <= 90; lat += 5){\n                            const { x, y, z } = latLngTo3D(lat, lng, radius);\n                            const rotated = rotatePoint({\n                                x,\n                                y,\n                                z\n                            }, interactionRef.current.rotationX, interactionRef.current.rotationY);\n                            if (rotated.z < 0) {\n                                // Only draw points on the front hemisphere\n                                const projected = project(rotated, centerX, centerY, interactionRef.current.zoom);\n                                points.push(projected);\n                            }\n                        }\n                        if (points.length > 1) {\n                            ctx.beginPath();\n                            ctx.moveTo(points[0].x, points[0].y);\n                            for(let j = 1; j < points.length; j++){\n                                ctx.lineTo(points[j].x, points[j].y);\n                            }\n                            ctx.strokeStyle = \"rgba(59, 130, 246, 0.2)\";\n                            ctx.lineWidth = 1;\n                            ctx.stroke();\n                        }\n                    }\n                    // Draw latitude lines (horizontal)\n                    for(let i = 1; i < numLatLines; i++){\n                        const lat = i / numLatLines * 180 - 90;\n                        const points = [];\n                        for(let lng = -180; lng <= 180; lng += 5){\n                            const { x, y, z } = latLngTo3D(lat, lng, radius);\n                            const rotated = rotatePoint({\n                                x,\n                                y,\n                                z\n                            }, interactionRef.current.rotationX, interactionRef.current.rotationY);\n                            if (rotated.z < 0) {\n                                // Only draw points on the front hemisphere\n                                const projected = project(rotated, centerX, centerY, interactionRef.current.zoom);\n                                points.push(projected);\n                            }\n                        }\n                        if (points.length > 1) {\n                            ctx.beginPath();\n                            ctx.moveTo(points[0].x, points[0].y);\n                            for(let j = 1; j < points.length; j++){\n                                ctx.lineTo(points[j].x, points[j].y);\n                            }\n                            ctx.strokeStyle = \"rgba(59, 130, 246, 0.2)\";\n                            ctx.lineWidth = 1;\n                            ctx.stroke();\n                        }\n                    }\n                    // Draw particles\n                    particles.forEach({\n                        \"GlobeVisualization.useEffect.drawGlobe\": (particle, i)=>{\n                            // Make particles move slowly around their position\n                            const offsetLng = particle.lng + Math.sin(animationProps.particleTime * particle.speed + particle.offset) * 5;\n                            const { x, y, z } = latLngTo3D(particle.lat, offsetLng, radius * 1.02);\n                            const rotated = rotatePoint({\n                                x,\n                                y,\n                                z\n                            }, interactionRef.current.rotationX, interactionRef.current.rotationY);\n                            if (rotated.z < 0) {\n                                // Only draw particles on the front hemisphere\n                                const projected = project(rotated, centerX, centerY, interactionRef.current.zoom);\n                                const particleSize = particle.size * projected.scale;\n                                // Fade particles based on their z position\n                                const opacity = 0.3 + 0.7 * (-rotated.z / radius);\n                                ctx.beginPath();\n                                ctx.arc(projected.x, projected.y, particleSize, 0, Math.PI * 2);\n                                ctx.fillStyle = `rgba(159, 220, 255, ${opacity})`;\n                                ctx.fill();\n                            }\n                        }\n                    }[\"GlobeVisualization.useEffect.drawGlobe\"]);\n                    // Draw connections between points\n                    connections.forEach({\n                        \"GlobeVisualization.useEffect.drawGlobe\": (connection, idx)=>{\n                            const pointA = projectedPoints.find({\n                                \"GlobeVisualization.useEffect.drawGlobe.pointA\": (p)=>p.index === connection[0]\n                            }[\"GlobeVisualization.useEffect.drawGlobe.pointA\"]);\n                            const pointB = projectedPoints.find({\n                                \"GlobeVisualization.useEffect.drawGlobe.pointB\": (p)=>p.index === connection[1]\n                            }[\"GlobeVisualization.useEffect.drawGlobe.pointB\"]);\n                            if (pointA && pointB && pointA.z < 0 && pointB.z < 0) {\n                                // Calculate animation progress for this connection\n                                const animation = animationProps.connectionAnimations[idx];\n                                animation.progress += animation.speed;\n                                if (animation.progress > 1) animation.progress = 0;\n                                // Draw the connection line\n                                ctx.beginPath();\n                                ctx.moveTo(pointA.projX, pointA.projY);\n                                ctx.lineTo(pointB.projX, pointB.projY);\n                                // Line opacity based on depth\n                                const avgDepth = (pointA.z + pointB.z) / 2;\n                                const depthFactor = Math.min(1, Math.max(0, -avgDepth / radius));\n                                const baseOpacity = 0.1 + 0.3 * depthFactor;\n                                ctx.strokeStyle = `rgba(79, 195, 247, ${baseOpacity})`;\n                                ctx.lineWidth = 1;\n                                ctx.stroke();\n                                // Draw animated pulse along the connection\n                                const pulsePos = animation.progress;\n                                const pulseX = pointA.projX + (pointB.projX - pointA.projX) * pulsePos;\n                                const pulseY = pointA.projY + (pointB.projY - pointA.projY) * pulsePos;\n                                ctx.beginPath();\n                                ctx.arc(pulseX, pulseY, 2, 0, Math.PI * 2);\n                                ctx.fillStyle = `rgba(79, 195, 247, ${0.7 * depthFactor})`;\n                                ctx.fill();\n                            }\n                        }\n                    }[\"GlobeVisualization.useEffect.drawGlobe\"]);\n                    // Draw points on the globe\n                    projectedPoints.forEach({\n                        \"GlobeVisualization.useEffect.drawGlobe\": (point)=>{\n                            if (point.z < 0) {\n                                // Only draw points on the front hemisphere\n                                const isHovered = animationProps.hoverPoint && animationProps.hoverPoint.index === point.index;\n                                // Calculate point size based on depth and hover state\n                                const baseSize = 3 * point.size;\n                                const sizeMultiplier = isHovered ? 1.5 : 1;\n                                const pointSize = baseSize * point.scale * sizeMultiplier;\n                                // Calculate opacity based on depth\n                                const depthFactor = Math.min(1, Math.max(0, -point.z / radius));\n                                const baseOpacity = 0.5 + 0.5 * depthFactor;\n                                // Pulse effect\n                                const pulseSize = isHovered ? 1.2 + 0.3 * Math.sin(animationProps.time * 5) : 1 + 0.1 * Math.sin(animationProps.time * 3);\n                                // Draw the point with glow effect\n                                drawGlowingCircle(point.projX, point.projY, pointSize * pulseSize, isHovered ? \"rgba(255, 255, 255, 0.9)\" : `rgba(79, 195, 247, ${baseOpacity})`, isHovered ? \"rgba(255, 255, 255, 0.4)\" : `rgba(79, 195, 247, ${baseOpacity * 0.5})`, pointSize * 2);\n                            }\n                        }\n                    }[\"GlobeVisualization.useEffect.drawGlobe\"]);\n                    // Draw equator with special highlight\n                    ctx.beginPath();\n                    const equatorPoints = [];\n                    for(let lng = -180; lng <= 180; lng += 5){\n                        const { x, y, z } = latLngTo3D(0, lng, radius);\n                        const rotated = rotatePoint({\n                            x,\n                            y,\n                            z\n                        }, interactionRef.current.rotationX, interactionRef.current.rotationY);\n                        if (rotated.z < 0) {\n                            // Only draw points on the front hemisphere\n                            const projected = project(rotated, centerX, centerY, interactionRef.current.zoom);\n                            equatorPoints.push(projected);\n                        }\n                    }\n                    if (equatorPoints.length > 1) {\n                        ctx.beginPath();\n                        ctx.moveTo(equatorPoints[0].x, equatorPoints[0].y);\n                        for(let j = 1; j < equatorPoints.length; j++){\n                            ctx.lineTo(equatorPoints[j].x, equatorPoints[j].y);\n                        }\n                        ctx.strokeStyle = \"rgba(79, 195, 247, 0.5)\";\n                        ctx.lineWidth = 1.5;\n                        ctx.stroke();\n                    }\n                    // Check if mouse is hovering over any point\n                    if (animationProps.hoverPoint) {\n                        const point = points[animationProps.hoverPoint.index];\n                        // Draw tooltip with city name\n                        ctx.font = \"14px Arial\";\n                        ctx.fillStyle = \"white\";\n                        ctx.textAlign = \"center\";\n                        ctx.fillText(point.name, animationProps.hoverPoint.x, animationProps.hoverPoint.y - 20);\n                    }\n                }\n            }[\"GlobeVisualization.useEffect.drawGlobe\"];\n            // Mouse event handlers\n            const handleMouseDown = {\n                \"GlobeVisualization.useEffect.handleMouseDown\": (e)=>{\n                    const rect = canvas.getBoundingClientRect();\n                    interactionRef.current.isMouseDown = true;\n                    interactionRef.current.lastMouseX = e.clientX - rect.left;\n                    interactionRef.current.lastMouseY = e.clientY - rect.top;\n                    setIsInteracting(true);\n                }\n            }[\"GlobeVisualization.useEffect.handleMouseDown\"];\n            const handleMouseMove = {\n                \"GlobeVisualization.useEffect.handleMouseMove\": (e)=>{\n                    const rect = canvas.getBoundingClientRect();\n                    const mouseX = e.clientX - rect.left;\n                    const mouseY = e.clientY - rect.top;\n                    // Check if mouse is hovering over any point\n                    const centerX = rect.width / 2;\n                    const centerY = rect.height / 2;\n                    const radius = Math.min(rect.width, rect.height) * 0.35 * interactionRef.current.zoom;\n                    let hoveredPoint = null;\n                    // Calculate all points' positions\n                    for(let i = 0; i < points.length; i++){\n                        const { x, y, z } = latLngTo3D(points[i].lat, points[i].lng, radius);\n                        const rotated = rotatePoint({\n                            x,\n                            y,\n                            z\n                        }, interactionRef.current.rotationX, interactionRef.current.rotationY);\n                        if (rotated.z < 0) {\n                            // Only check points on the front hemisphere\n                            const projected = project(rotated, centerX, centerY, interactionRef.current.zoom);\n                            const distance = Math.sqrt(Math.pow(mouseX - projected.x, 2) + Math.pow(mouseY - projected.y, 2));\n                            if (distance < 15) {\n                                hoveredPoint = {\n                                    x: projected.x,\n                                    y: projected.y,\n                                    index: i\n                                };\n                                break;\n                            }\n                        }\n                    }\n                    animationProps.hoverPoint = hoveredPoint;\n                    // Handle dragging for rotation\n                    if (interactionRef.current.isMouseDown) {\n                        const deltaX = mouseX - interactionRef.current.lastMouseX;\n                        const deltaY = mouseY - interactionRef.current.lastMouseY;\n                        interactionRef.current.rotationY += deltaX * 0.01;\n                        interactionRef.current.rotationX += deltaY * 0.01;\n                        interactionRef.current.lastMouseX = mouseX;\n                        interactionRef.current.lastMouseY = mouseY;\n                    }\n                }\n            }[\"GlobeVisualization.useEffect.handleMouseMove\"];\n            const handleMouseUp = {\n                \"GlobeVisualization.useEffect.handleMouseUp\": ()=>{\n                    interactionRef.current.isMouseDown = false;\n                    setIsInteracting(false);\n                }\n            }[\"GlobeVisualization.useEffect.handleMouseUp\"];\n            const handleMouseLeave = {\n                \"GlobeVisualization.useEffect.handleMouseLeave\": ()=>{\n                    interactionRef.current.isMouseDown = false;\n                    setIsInteracting(false);\n                }\n            }[\"GlobeVisualization.useEffect.handleMouseLeave\"];\n            const handleWheel = {\n                \"GlobeVisualization.useEffect.handleWheel\": (e)=>{\n                    e.preventDefault();\n                    // Adjust zoom level with mouse wheel\n                    const zoomDelta = e.deltaY * -0.001;\n                    interactionRef.current.zoom = Math.max(0.5, Math.min(2, interactionRef.current.zoom + zoomDelta));\n                }\n            }[\"GlobeVisualization.useEffect.handleWheel\"];\n            // Add event listeners\n            canvas.addEventListener(\"mousedown\", handleMouseDown);\n            canvas.addEventListener(\"mousemove\", handleMouseMove);\n            canvas.addEventListener(\"mouseup\", handleMouseUp);\n            canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n            canvas.addEventListener(\"wheel\", handleWheel);\n            // Animation loop\n            let animationId;\n            const animate = {\n                \"GlobeVisualization.useEffect.animate\": (timestamp)=>{\n                    drawGlobe(timestamp);\n                    animationId = requestAnimationFrame(animate);\n                }\n            }[\"GlobeVisualization.useEffect.animate\"];\n            animationId = requestAnimationFrame(animate);\n            // Cleanup on component unmount\n            return ({\n                \"GlobeVisualization.useEffect\": ()=>{\n                    window.removeEventListener(\"resize\", setCanvasDimensions);\n                    canvas.removeEventListener(\"mousedown\", handleMouseDown);\n                    canvas.removeEventListener(\"mousemove\", handleMouseMove);\n                    canvas.removeEventListener(\"mouseup\", handleMouseUp);\n                    canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n                    canvas.removeEventListener(\"wheel\", handleWheel);\n                    cancelAnimationFrame(animationId);\n                }\n            })[\"GlobeVisualization.useEffect\"];\n        }\n    }[\"GlobeVisualization.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: `globe-canvas w-full h-full block ${isInteracting ? \"shadow-[0_0_30px_rgba(59,130,246,0.5)]\" : \"\"}`\n    }, void 0, false, {\n        fileName: \"C:\\\\Data\\\\workspace\\\\React\\\\bolt\\\\src\\\\components\\\\globe-visualization.tsx\",\n        lineNumber: 595,\n        columnNumber: 5\n    }, this);\n}\n_s(GlobeVisualization, \"A4AtGc+OcW0TOIQEAiXff6ERHXc=\");\n_c = GlobeVisualization;\nvar _c;\n$RefreshReg$(_c, \"GlobeVisualization\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2dsb2JlLXZpc3VhbGl6YXRpb24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUltRDtBQUVwQyxTQUFTRzs7SUFDdEIsTUFBTUMsWUFBWUosNkNBQU1BLENBQW9CO0lBQzVDLE1BQU0sQ0FBQ0ssZUFBZUMsaUJBQWlCLEdBQUdKLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU1LLGlCQUFpQlAsNkNBQU1BLENBQUM7UUFDNUJRLGFBQWE7UUFDYkMsWUFBWTtRQUNaQyxZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsZ0JBQWdCO1FBQ2hCQyxXQUFXO1FBQ1hDLFdBQVc7UUFDWEMsTUFBTTtJQUNSO0lBRUFkLGdEQUFTQTt3Q0FBQztZQUNSLE1BQU1lLFNBQVNaLFVBQVVhLE9BQU87WUFDaEMsSUFBSSxDQUFDRCxRQUFRO1lBRWIsTUFBTUUsTUFBTUYsT0FBT0csVUFBVSxDQUFDO1lBQzlCLElBQUksQ0FBQ0QsS0FBSztZQUVWLCtFQUErRTtZQUMvRSxNQUFNRTtvRUFBc0I7b0JBQzFCLE1BQU1DLFlBQVlMLE9BQU9NLGFBQWE7b0JBQ3RDLElBQUlELFdBQVc7d0JBQ2IsTUFBTUUsbUJBQW1CQyxPQUFPRCxnQkFBZ0IsSUFBSTt3QkFDcERQLE9BQU9TLEtBQUssR0FBR0osVUFBVUssV0FBVyxHQUFHSDt3QkFDdkNQLE9BQU9XLE1BQU0sR0FBR04sVUFBVU8sWUFBWSxHQUFHTDt3QkFDekNQLE9BQU9hLEtBQUssQ0FBQ0osS0FBSyxHQUFHLEdBQUdKLFVBQVVLLFdBQVcsQ0FBQyxFQUFFLENBQUM7d0JBQ2pEVixPQUFPYSxLQUFLLENBQUNGLE1BQU0sR0FBRyxHQUFHTixVQUFVTyxZQUFZLENBQUMsRUFBRSxDQUFDO3dCQUNuRFYsSUFBSVksS0FBSyxDQUFDUCxrQkFBa0JBO29CQUM5QjtnQkFDRjs7WUFFQUg7WUFDQUksT0FBT08sZ0JBQWdCLENBQUMsVUFBVVg7WUFFbEMsMENBQTBDO1lBQzFDLE1BQU1Z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c0JEO2dCQUN0Qzs7WUFDQUQsY0FBY0Usc0JBQXNCRDtZQUVwQywrQkFBK0I7WUFDL0I7Z0RBQU87b0JBQ0xqSixPQUFPbUosbUJBQW1CLENBQUMsVUFBVXZKO29CQUNyQ0osT0FBTzJKLG1CQUFtQixDQUFDLGFBQWF6QjtvQkFDeENsSSxPQUFPMkosbUJBQW1CLENBQUMsYUFBYWpCO29CQUN4QzFJLE9BQU8ySixtQkFBbUIsQ0FBQyxXQUFXUjtvQkFDdENuSixPQUFPMkosbUJBQW1CLENBQUMsY0FBY1A7b0JBQ3pDcEosT0FBTzJKLG1CQUFtQixDQUFDLFNBQVNOO29CQUNwQ08scUJBQXFCSjtnQkFDdkI7O1FBQ0Y7dUNBQUcsRUFBRTtJQUVMLHFCQUNFLDhEQUFDeEo7UUFDQzZKLEtBQUt6SztRQUNMMEssV0FBVyxDQUFDLGlDQUFpQyxFQUFFekssZ0JBQWdCLDJDQUEyQyxJQUFJOzs7Ozs7QUFHcEg7R0FqbEJ3QkY7S0FBQUEiLCJzb3VyY2VzIjpbIkM6XFxEYXRhXFx3b3Jrc3BhY2VcXFJlYWN0XFxib2x0XFxzcmNcXGNvbXBvbmVudHNcXGdsb2JlLXZpc3VhbGl6YXRpb24udHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5cclxuXCJ1c2UgY2xpZW50XCJcclxuXHJcbmltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBHbG9iZVZpc3VhbGl6YXRpb24oKTogSlNYLkVsZW1lbnQge1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbClcclxuICBjb25zdCBbaXNJbnRlcmFjdGluZywgc2V0SXNJbnRlcmFjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBpbnRlcmFjdGlvblJlZiA9IHVzZVJlZih7XHJcbiAgICBpc01vdXNlRG93bjogZmFsc2UsXHJcbiAgICBsYXN0TW91c2VYOiAwLFxyXG4gICAgbGFzdE1vdXNlWTogMCxcclxuICAgIHJvdGF0aW9uU3BlZWRYOiAwLjAwMyxcclxuICAgIHJvdGF0aW9uU3BlZWRZOiAwLjAwMSxcclxuICAgIHJvdGF0aW9uWDogMCxcclxuICAgIHJvdGF0aW9uWTogMCxcclxuICAgIHpvb206IDEsXHJcbiAgfSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXHJcblxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxyXG4gICAgaWYgKCFjdHgpIHJldHVyblxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIHNldCBjYW52YXMgZGltZW5zaW9ucyB3aXRoIGhpZ2hlciByZXNvbHV0aW9uIGZvciByZXRpbmEgZGlzcGxheXNcclxuICAgIGNvbnN0IHNldENhbnZhc0RpbWVuc2lvbnMgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcy5wYXJlbnRFbGVtZW50XHJcbiAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMVxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aCAqIGRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjb250YWluZXIuY2xpZW50V2lkdGh9cHhgXHJcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NvbnRhaW5lci5jbGllbnRIZWlnaHR9cHhgXHJcbiAgICAgICAgY3R4LnNjYWxlKGRldmljZVBpeGVsUmF0aW8sIGRldmljZVBpeGVsUmF0aW8pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRDYW52YXNEaW1lbnNpb25zKClcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHNldENhbnZhc0RpbWVuc2lvbnMpXHJcblxyXG4gICAgLy8gRGVmaW5lIGNvbm5lY3Rpb24gcG9pbnRzIChtYWpvciBjaXRpZXMpXHJcbiAgICBjb25zdCBwb2ludHMgPSBbXHJcbiAgICAgIHsgbGF0OiA0MC43MTI4LCBsbmc6IC03NC4wMDYsIG5hbWU6IFwiTmV3IFlvcmtcIiwgc2l6ZTogMS4yIH0sXHJcbiAgICAgIHsgbGF0OiA1MS41MDc0LCBsbmc6IC0wLjEyNzgsIG5hbWU6IFwiTG9uZG9uXCIsIHNpemU6IDEuMiB9LFxyXG4gICAgICB7IGxhdDogMzUuNjc2MiwgbG5nOiAxMzkuNjUwMywgbmFtZTogXCJUb2t5b1wiLCBzaXplOiAxLjIgfSxcclxuICAgICAgeyBsYXQ6IC0zMy44Njg4LCBsbmc6IDE1MS4yMDkzLCBuYW1lOiBcIlN5ZG5leVwiLCBzaXplOiAxIH0sXHJcbiAgICAgIHsgbGF0OiAzNy43NzQ5LCBsbmc6IC0xMjIuNDE5NCwgbmFtZTogXCJTYW4gRnJhbmNpc2NvXCIsIHNpemU6IDEgfSxcclxuICAgICAgeyBsYXQ6IDE5LjA3NiwgbG5nOiA3Mi44Nzc3LCBuYW1lOiBcIk11bWJhaVwiLCBzaXplOiAxIH0sXHJcbiAgICAgIHsgbGF0OiAtMjMuNTUwNSwgbG5nOiAtNDYuNjMzMywgbmFtZTogXCJTw6NvIFBhdWxvXCIsIHNpemU6IDEgfSxcclxuICAgICAgeyBsYXQ6IDQ4Ljg1NjYsIGxuZzogMi4zNTIyLCBuYW1lOiBcIlBhcmlzXCIsIHNpemU6IDEgfSxcclxuICAgICAgeyBsYXQ6IDU1Ljc1NTgsIGxuZzogMzcuNjE3MywgbmFtZTogXCJNb3Njb3dcIiwgc2l6ZTogMSB9LFxyXG4gICAgICB7IGxhdDogMzEuMjMwNCwgbG5nOiAxMjEuNDczNywgbmFtZTogXCJTaGFuZ2hhaVwiLCBzaXplOiAxLjEgfSxcclxuICAgICAgeyBsYXQ6IC02LjIwODgsIGxuZzogMTA2Ljg0NTYsIG5hbWU6IFwiSmFrYXJ0YVwiLCBzaXplOiAxIH0sXHJcbiAgICAgIHsgbGF0OiAyOC42MTM5LCBsbmc6IDc3LjIwOSwgbmFtZTogXCJOZXcgRGVsaGlcIiwgc2l6ZTogMSB9LFxyXG4gICAgICB7IGxhdDogMjUuMjA0OCwgbG5nOiA1NS4yNzA4LCBuYW1lOiBcIkR1YmFpXCIsIHNpemU6IDEgfSxcclxuICAgICAgeyBsYXQ6IC0zNC42MDM3LCBsbmc6IC01OC4zODE2LCBuYW1lOiBcIkJ1ZW5vcyBBaXJlc1wiLCBzaXplOiAxIH0sXHJcbiAgICAgIHsgbGF0OiAzMC4wNDQ0LCBsbmc6IDMxLjIzNTcsIG5hbWU6IFwiQ2Fpcm9cIiwgc2l6ZTogMSB9LFxyXG4gICAgICB7IGxhdDogNTkuMzI5MywgbG5nOiAxOC4wNjg2LCBuYW1lOiBcIlN0b2NraG9sbVwiLCBzaXplOiAwLjkgfSxcclxuICAgICAgeyBsYXQ6IC0xLjI5MjEsIGxuZzogMzYuODIxOSwgbmFtZTogXCJOYWlyb2JpXCIsIHNpemU6IDAuOSB9LFxyXG4gICAgICB7IGxhdDogNDEuMDA4MiwgbG5nOiAyOC45Nzg0LCBuYW1lOiBcIklzdGFuYnVsXCIsIHNpemU6IDEgfSxcclxuICAgICAgeyBsYXQ6IDEuMzUyMSwgbG5nOiAxMDMuODE5OCwgbmFtZTogXCJTaW5nYXBvcmVcIiwgc2l6ZTogMSB9LFxyXG4gICAgICB7IGxhdDogLTI2LjIwNDEsIGxuZzogMjguMDQ3MywgbmFtZTogXCJKb2hhbm5lc2J1cmdcIiwgc2l6ZTogMC45IH0sXHJcbiAgICBdXHJcblxyXG4gICAgLy8gQ3JlYXRlIGNvbm5lY3Rpb24gcGFpcnMgKG5vdCBhbGwgY2l0aWVzIGNvbm5lY3QgdG8gYWxsIG90aGVycylcclxuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gW1xyXG4gICAgICBbMCwgMV0sXHJcbiAgICAgIFswLCA0XSxcclxuICAgICAgWzAsIDZdLFxyXG4gICAgICBbMCwgN10sXHJcbiAgICAgIFswLCA5XSxcclxuICAgICAgWzAsIDEzXSxcclxuICAgICAgWzEsIDddLFxyXG4gICAgICBbMSwgOF0sXHJcbiAgICAgIFsxLCAxMV0sXHJcbiAgICAgIFsxLCAxMl0sXHJcbiAgICAgIFsxLCAxN10sXHJcbiAgICAgIFsyLCA0XSxcclxuICAgICAgWzIsIDldLFxyXG4gICAgICBbMiwgMTBdLFxyXG4gICAgICBbMiwgMThdLFxyXG4gICAgICBbMywgNl0sXHJcbiAgICAgIFszLCAxMF0sXHJcbiAgICAgIFszLCAxOF0sXHJcbiAgICAgIFszLCAxOV0sXHJcbiAgICAgIFs0LCA5XSxcclxuICAgICAgWzQsIDE4XSxcclxuICAgICAgWzUsIDExXSxcclxuICAgICAgWzUsIDEyXSxcclxuICAgICAgWzUsIDE4XSxcclxuICAgICAgWzYsIDEzXSxcclxuICAgICAgWzYsIDE5XSxcclxuICAgICAgWzcsIDhdLFxyXG4gICAgICBbNywgMTddLFxyXG4gICAgICBbOCwgMTFdLFxyXG4gICAgICBbOCwgMTddLFxyXG4gICAgICBbOSwgMTBdLFxyXG4gICAgICBbOSwgMTFdLFxyXG4gICAgICBbMTAsIDE4XSxcclxuICAgICAgWzExLCAxMl0sXHJcbiAgICAgIFsxMiwgMTZdLFxyXG4gICAgICBbMTIsIDE5XSxcclxuICAgICAgWzE0LCAxNl0sXHJcbiAgICAgIFsxNCwgMTddLFxyXG4gICAgICBbMTQsIDE5XSxcclxuICAgICAgWzE1LCAxN10sXHJcbiAgICAgIFsxNiwgMTldLFxyXG4gICAgXVxyXG5cclxuICAgIC8vIEFuaW1hdGlvbiBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBhbmltYXRpb25Qcm9wcyA9IHtcclxuICAgICAgdGltZTogMCxcclxuICAgICAgcHVsc2VTcGVlZDogMC4wMixcclxuICAgICAgY29ubmVjdGlvbkFuaW1hdGlvbnM6IGNvbm5lY3Rpb25zLm1hcCgoKSA9PiAoeyBwcm9ncmVzczogTWF0aC5yYW5kb20oKSwgc3BlZWQ6IDAuMDAyICsgTWF0aC5yYW5kb20oKSAqIDAuMDAzIH0pKSxcclxuICAgICAgaG92ZXJQb2ludDogbnVsbCBhcyB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBpbmRleDogbnVtYmVyIH0gfCBudWxsLFxyXG4gICAgICBwYXJ0aWNsZVRpbWU6IDAsXHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgcmFuZG9tIHBhcnRpY2xlcyBhcm91bmQgdGhlIGdsb2JlXHJcbiAgICBjb25zdCBudW1QYXJ0aWNsZXMgPSAxNTBcclxuICAgIGNvbnN0IHBhcnRpY2xlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG51bVBhcnRpY2xlcyB9LCAoKSA9PiAoe1xyXG4gICAgICBsYXQ6IE1hdGgucmFuZG9tKCkgKiAxODAgLSA5MCxcclxuICAgICAgbG5nOiBNYXRoLnJhbmRvbSgpICogMzYwIC0gMTgwLFxyXG4gICAgICBzaXplOiAwLjIgKyBNYXRoLnJhbmRvbSgpICogMC41LFxyXG4gICAgICBzcGVlZDogMC4xICsgTWF0aC5yYW5kb20oKSAqIDAuMyxcclxuICAgICAgb2Zmc2V0OiBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXHJcbiAgICB9KSlcclxuXHJcbiAgICAvLyBGdW5jdGlvbiB0byBjb252ZXJ0IGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgaW50byAzRCBjb29yZGluYXRlcyBvbiB0aGUgZ2xvYmVcclxuICAgIGNvbnN0IGxhdExuZ1RvM0QgPSAobGF0OiBudW1iZXIsIGxuZzogbnVtYmVyLCByYWRpdXM6IG51bWJlcikgPT4ge1xyXG4gICAgICBjb25zdCBwaGkgPSAoOTAgLSBsYXQpICogKE1hdGguUEkgLyAxODApXHJcbiAgICAgIGNvbnN0IHRoZXRhID0gKGxuZyArIDE4MCkgKiAoTWF0aC5QSSAvIDE4MClcclxuICAgICAgY29uc3QgeCA9IC1yYWRpdXMgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpXHJcbiAgICAgIGNvbnN0IHkgPSByYWRpdXMgKiBNYXRoLmNvcyhwaGkpXHJcbiAgICAgIGNvbnN0IHogPSByYWRpdXMgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpXHJcbiAgICAgIHJldHVybiB7IHgsIHksIHogfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIHJvdGF0ZSBhIDNEIHBvaW50IGFyb3VuZCB0aGUgWSBhbmQgWCBheGVzXHJcbiAgICBjb25zdCByb3RhdGVQb2ludCA9IChwb2ludDogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0sIHJvdGF0aW9uWDogbnVtYmVyLCByb3RhdGlvblk6IG51bWJlcikgPT4ge1xyXG4gICAgICAvLyBSb3RhdGUgYXJvdW5kIFkgYXhpc1xyXG4gICAgICBjb25zdCBjb3NZID0gTWF0aC5jb3Mocm90YXRpb25ZKVxyXG4gICAgICBjb25zdCBzaW5ZID0gTWF0aC5zaW4ocm90YXRpb25ZKVxyXG4gICAgICBjb25zdCB4MSA9IHBvaW50LnggKiBjb3NZIC0gcG9pbnQueiAqIHNpbllcclxuICAgICAgY29uc3QgejEgPSBwb2ludC56ICogY29zWSArIHBvaW50LnggKiBzaW5ZXHJcblxyXG4gICAgICAvLyBSb3RhdGUgYXJvdW5kIFggYXhpc1xyXG4gICAgICBjb25zdCBjb3NYID0gTWF0aC5jb3Mocm90YXRpb25YKVxyXG4gICAgICBjb25zdCBzaW5YID0gTWF0aC5zaW4ocm90YXRpb25YKVxyXG4gICAgICBjb25zdCB5MiA9IHBvaW50LnkgKiBjb3NYIC0gejEgKiBzaW5YXHJcbiAgICAgIGNvbnN0IHoyID0gejEgKiBjb3NYICsgcG9pbnQueSAqIHNpblhcclxuXHJcbiAgICAgIHJldHVybiB7IHg6IHgxLCB5OiB5MiwgejogejIgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIHByb2plY3QgYSAzRCBwb2ludCBvbnRvIHRoZSAyRCBjYW52YXNcclxuICAgIGNvbnN0IHByb2plY3QgPSAocG9pbnQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHo6IG51bWJlciB9LCBjZW50ZXJYOiBudW1iZXIsIGNlbnRlclk6IG51bWJlciwgem9vbTogbnVtYmVyKSA9PiB7XHJcbiAgICAgIC8vIFNpbXBsZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uXHJcbiAgICAgIGNvbnN0IGZvdiA9IDMwMFxyXG4gICAgICBjb25zdCB2aWV3WiA9IGZvdiArIHBvaW50LnogKiB6b29tXHJcbiAgICAgIGNvbnN0IHNjYWxlID0gZm92IC8gTWF0aC5tYXgoMSwgdmlld1opXHJcbiAgICAgIGNvbnN0IHggPSBjZW50ZXJYICsgcG9pbnQueCAqIHNjYWxlICogem9vbVxyXG4gICAgICBjb25zdCB5ID0gY2VudGVyWSArIHBvaW50LnkgKiBzY2FsZSAqIHpvb21cclxuICAgICAgcmV0dXJuIHsgeCwgeSwgc2NhbGUsIGRlcHRoOiB2aWV3WiB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRnVuY3Rpb24gdG8gZHJhdyBhIGdsb3dpbmcgY2lyY2xlXHJcbiAgICBjb25zdCBkcmF3R2xvd2luZ0NpcmNsZSA9IChcclxuICAgICAgeDogbnVtYmVyLFxyXG4gICAgICB5OiBudW1iZXIsXHJcbiAgICAgIHJhZGl1czogbnVtYmVyLFxyXG4gICAgICBjb2xvcjogc3RyaW5nLFxyXG4gICAgICBnbG93Q29sb3I6IHN0cmluZyxcclxuICAgICAgZ2xvd1NpemU6IG51bWJlcixcclxuICAgICkgPT4ge1xyXG4gICAgICAvLyBEcmF3IG91dGVyIGdsb3dcclxuICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgcmFkaXVzLCB4LCB5LCByYWRpdXMgKyBnbG93U2l6ZSlcclxuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGdsb3dDb2xvcilcclxuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwicmdiYSgwLCAwLCAwLCAwKVwiKVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnRcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgZ2xvd1NpemUsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICBjdHguZmlsbCgpXHJcblxyXG4gICAgICAvLyBEcmF3IGlubmVyIGNpcmNsZVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGwoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZ1bmN0aW9uIHRvIGRyYXcgdGhlIGdsb2JlIGFuZCBpdHMgZ3JpZCwgcG9pbnRzLCBhbmQgY29ubmVjdGlvbnNcclxuICAgIGNvbnN0IGRyYXdHbG9iZSA9ICh0aW1lc3RhbXA6IG51bWJlcikgPT4ge1xyXG4gICAgICBpZiAoIWN0eCB8fCAhY2FudmFzKSByZXR1cm5cclxuXHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcy5wYXJlbnRFbGVtZW50XHJcbiAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm5cclxuXHJcbiAgICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoXHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHRcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxyXG5cclxuICAgICAgY29uc3QgY2VudGVyWCA9IHdpZHRoIC8gMlxyXG4gICAgICBjb25zdCBjZW50ZXJZID0gaGVpZ2h0IC8gMlxyXG4gICAgICBjb25zdCBiYXNlUmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgKiAwLjM1XHJcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGJhc2VSYWRpdXMgKiBpbnRlcmFjdGlvblJlZi5jdXJyZW50Lnpvb21cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSByb3RhdGlvbiBiYXNlZCBvbiBpbnRlcmFjdGlvbiBvciBhdXRvLXJvdGF0aW9uXHJcbiAgICAgIGlmICghaW50ZXJhY3Rpb25SZWYuY3VycmVudC5pc01vdXNlRG93bikge1xyXG4gICAgICAgIGludGVyYWN0aW9uUmVmLmN1cnJlbnQucm90YXRpb25ZICs9IGludGVyYWN0aW9uUmVmLmN1cnJlbnQucm90YXRpb25TcGVlZFlcclxuICAgICAgICBpbnRlcmFjdGlvblJlZi5jdXJyZW50LnJvdGF0aW9uWCArPSBpbnRlcmFjdGlvblJlZi5jdXJyZW50LnJvdGF0aW9uU3BlZWRYXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb24gdGltZVxyXG4gICAgICBhbmltYXRpb25Qcm9wcy50aW1lICs9IDAuMDFcclxuICAgICAgYW5pbWF0aW9uUHJvcHMucGFydGljbGVUaW1lICs9IDAuMDA1XHJcblxyXG4gICAgICAvLyBEcmF3IHRoZSBnbG9iZSBiYWNrZ3JvdW5kICh3aXRoIGdyYWRpZW50KVxyXG4gICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChjZW50ZXJYLCBjZW50ZXJZLCAwLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgKiAxLjIpXHJcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBcInJnYmEoMzAsIDY0LCAxNzUsIDAuMilcIilcclxuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNSwgXCJyZ2JhKDMwLCA2NCwgMTc1LCAwLjE1KVwiKVxyXG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDMwLCA2NCwgMTc1LCAwKVwiKVxyXG5cclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzICogMS4yLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50XHJcbiAgICAgIGN0eC5maWxsKClcclxuXHJcbiAgICAgIC8vIERyYXcgdGhlIGdsb2JlIG91dGVyIGdsb3dcclxuICAgICAgY29uc3QgZ2xvd0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyAqIDAuOSwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzICogMS4zKVxyXG4gICAgICBnbG93R3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwicmdiYSg1OSwgMTMwLCAyNDYsIDAuMilcIilcclxuICAgICAgZ2xvd0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoNTksIDEzMCwgMjQ2LCAwKVwiKVxyXG5cclxuICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzICogMS4zLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdsb3dHcmFkaWVudFxyXG4gICAgICBjdHguZmlsbCgpXHJcblxyXG4gICAgICAvLyBEcmF3IHRoZSBnbG9iZSAoY2lyY2xlIHdpdGggZ3JhZGllbnQpXHJcbiAgICAgIGNvbnN0IHNwaGVyZUdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxyXG4gICAgICAgIGNlbnRlclggLSByYWRpdXMgKiAwLjMsXHJcbiAgICAgICAgY2VudGVyWSAtIHJhZGl1cyAqIDAuMyxcclxuICAgICAgICAwLFxyXG4gICAgICAgIGNlbnRlclgsXHJcbiAgICAgICAgY2VudGVyWSxcclxuICAgICAgICByYWRpdXMsXHJcbiAgICAgIClcclxuICAgICAgc3BoZXJlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwicmdiYSg1OSwgMTMwLCAyNDYsIDAuNClcIilcclxuICAgICAgc3BoZXJlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNywgXCJyZ2JhKDMwLCA2NCwgMTc1LCAwLjMpXCIpXHJcbiAgICAgIHNwaGVyZUdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoMzAsIDY0LCAxNzUsIDAuMilcIilcclxuXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBzcGhlcmVHcmFkaWVudFxyXG4gICAgICBjdHguZmlsbCgpXHJcblxyXG4gICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoNTksIDEzMCwgMjQ2LCAwLjYpXCJcclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IDJcclxuICAgICAgY3R4LnN0cm9rZSgpXHJcblxyXG4gICAgICAvLyBTdG9yZSBhbGwgcHJvamVjdGVkIHBvaW50cyBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgIGNvbnN0IHByb2plY3RlZFBvaW50czogQXJyYXk8e1xyXG4gICAgICAgIHg6IG51bWJlclxyXG4gICAgICAgIHk6IG51bWJlclxyXG4gICAgICAgIHo6IG51bWJlclxyXG4gICAgICAgIHByb2pYOiBudW1iZXJcclxuICAgICAgICBwcm9qWTogbnVtYmVyXHJcbiAgICAgICAgc2NhbGU6IG51bWJlclxyXG4gICAgICAgIGRlcHRoOiBudW1iZXJcclxuICAgICAgICBpbmRleDogbnVtYmVyXHJcbiAgICAgICAgc2l6ZTogbnVtYmVyXHJcbiAgICAgIH0+ID0gW11cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBhbmQgc3RvcmUgYWxsIHByb2plY3RlZCBwb2ludHNcclxuICAgICAgcG9pbnRzLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gbGF0TG5nVG8zRChwb2ludC5sYXQsIHBvaW50LmxuZywgcmFkaXVzKVxyXG4gICAgICAgIGNvbnN0IHJvdGF0ZWQgPSByb3RhdGVQb2ludCh7IHgsIHksIHogfSwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5yb3RhdGlvblgsIGludGVyYWN0aW9uUmVmLmN1cnJlbnQucm90YXRpb25ZKVxyXG4gICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHByb2plY3Qocm90YXRlZCwgY2VudGVyWCwgY2VudGVyWSwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC56b29tKVxyXG5cclxuICAgICAgICBwcm9qZWN0ZWRQb2ludHMucHVzaCh7XHJcbiAgICAgICAgICB4OiByb3RhdGVkLngsXHJcbiAgICAgICAgICB5OiByb3RhdGVkLnksXHJcbiAgICAgICAgICB6OiByb3RhdGVkLnosXHJcbiAgICAgICAgICBwcm9qWDogcHJvamVjdGVkLngsXHJcbiAgICAgICAgICBwcm9qWTogcHJvamVjdGVkLnksXHJcbiAgICAgICAgICBzY2FsZTogcHJvamVjdGVkLnNjYWxlLFxyXG4gICAgICAgICAgZGVwdGg6IHByb2plY3RlZC5kZXB0aCxcclxuICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgc2l6ZTogcG9pbnQuc2l6ZSB8fCAxLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyBTb3J0IHBvaW50cyBieSB6LWRlcHRoIGZvciBwcm9wZXIgcmVuZGVyaW5nXHJcbiAgICAgIHByb2plY3RlZFBvaW50cy5zb3J0KChhLCBiKSA9PiBhLnogLSBiLnopXHJcblxyXG4gICAgICAvLyBEcmF3IGdyaWQgbGluZXMgKGxhdGl0dWRlIGFuZCBsb25naXR1ZGUpXHJcbiAgICAgIGNvbnN0IG51bUxhdExpbmVzID0gMTBcclxuICAgICAgY29uc3QgbnVtTG5nTGluZXMgPSAxOFxyXG5cclxuICAgICAgLy8gRHJhdyBsb25naXR1ZGUgbGluZXMgKHZlcnRpY2FsKVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUxuZ0xpbmVzOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsbmcgPSAoaSAvIG51bUxuZ0xpbmVzKSAqIDM2MCAtIDE4MFxyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdXHJcblxyXG4gICAgICAgIGZvciAobGV0IGxhdCA9IC05MDsgbGF0IDw9IDkwOyBsYXQgKz0gNSkge1xyXG4gICAgICAgICAgY29uc3QgeyB4LCB5LCB6IH0gPSBsYXRMbmdUbzNEKGxhdCwgbG5nLCByYWRpdXMpXHJcbiAgICAgICAgICBjb25zdCByb3RhdGVkID0gcm90YXRlUG9pbnQoeyB4LCB5LCB6IH0sIGludGVyYWN0aW9uUmVmLmN1cnJlbnQucm90YXRpb25YLCBpbnRlcmFjdGlvblJlZi5jdXJyZW50LnJvdGF0aW9uWSlcclxuXHJcbiAgICAgICAgICBpZiAocm90YXRlZC56IDwgMCkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGRyYXcgcG9pbnRzIG9uIHRoZSBmcm9udCBoZW1pc3BoZXJlXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHByb2plY3Qocm90YXRlZCwgY2VudGVyWCwgY2VudGVyWSwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC56b29tKVxyXG4gICAgICAgICAgICBwb2ludHMucHVzaChwcm9qZWN0ZWQpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxyXG4gICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpXHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbal0ueCwgcG9pbnRzW2pdLnkpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDU5LCAxMzAsIDI0NiwgMC4yKVwiXHJcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gMVxyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEcmF3IGxhdGl0dWRlIGxpbmVzIChob3Jpem9udGFsKVxyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bUxhdExpbmVzOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsYXQgPSAoaSAvIG51bUxhdExpbmVzKSAqIDE4MCAtIDkwXHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW11cclxuXHJcbiAgICAgICAgZm9yIChsZXQgbG5nID0gLTE4MDsgbG5nIDw9IDE4MDsgbG5nICs9IDUpIHtcclxuICAgICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gbGF0TG5nVG8zRChsYXQsIGxuZywgcmFkaXVzKVxyXG4gICAgICAgICAgY29uc3Qgcm90YXRlZCA9IHJvdGF0ZVBvaW50KHsgeCwgeSwgeiB9LCBpbnRlcmFjdGlvblJlZi5jdXJyZW50LnJvdGF0aW9uWCwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5yb3RhdGlvblkpXHJcblxyXG4gICAgICAgICAgaWYgKHJvdGF0ZWQueiA8IDApIHtcclxuICAgICAgICAgICAgLy8gT25seSBkcmF3IHBvaW50cyBvbiB0aGUgZnJvbnQgaGVtaXNwaGVyZVxyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwcm9qZWN0KHJvdGF0ZWQsIGNlbnRlclgsIGNlbnRlclksIGludGVyYWN0aW9uUmVmLmN1cnJlbnQuem9vbSlcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gocHJvamVjdGVkKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KVxyXG5cclxuICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2pdLngsIHBvaW50c1tqXS55KVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSg1OSwgMTMwLCAyNDYsIDAuMilcIlxyXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDFcclxuICAgICAgICAgIGN0eC5zdHJva2UoKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyBwYXJ0aWNsZXNcclxuICAgICAgcGFydGljbGVzLmZvckVhY2goKHBhcnRpY2xlLCBpKSA9PiB7XHJcbiAgICAgICAgLy8gTWFrZSBwYXJ0aWNsZXMgbW92ZSBzbG93bHkgYXJvdW5kIHRoZWlyIHBvc2l0aW9uXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0TG5nID0gcGFydGljbGUubG5nICsgTWF0aC5zaW4oYW5pbWF0aW9uUHJvcHMucGFydGljbGVUaW1lICogcGFydGljbGUuc3BlZWQgKyBwYXJ0aWNsZS5vZmZzZXQpICogNVxyXG5cclxuICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IGxhdExuZ1RvM0QocGFydGljbGUubGF0LCBvZmZzZXRMbmcsIHJhZGl1cyAqIDEuMDIpXHJcbiAgICAgICAgY29uc3Qgcm90YXRlZCA9IHJvdGF0ZVBvaW50KHsgeCwgeSwgeiB9LCBpbnRlcmFjdGlvblJlZi5jdXJyZW50LnJvdGF0aW9uWCwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5yb3RhdGlvblkpXHJcblxyXG4gICAgICAgIGlmIChyb3RhdGVkLnogPCAwKSB7XHJcbiAgICAgICAgICAvLyBPbmx5IGRyYXcgcGFydGljbGVzIG9uIHRoZSBmcm9udCBoZW1pc3BoZXJlXHJcbiAgICAgICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwcm9qZWN0KHJvdGF0ZWQsIGNlbnRlclgsIGNlbnRlclksIGludGVyYWN0aW9uUmVmLmN1cnJlbnQuem9vbSlcclxuICAgICAgICAgIGNvbnN0IHBhcnRpY2xlU2l6ZSA9IHBhcnRpY2xlLnNpemUgKiBwcm9qZWN0ZWQuc2NhbGVcclxuXHJcbiAgICAgICAgICAvLyBGYWRlIHBhcnRpY2xlcyBiYXNlZCBvbiB0aGVpciB6IHBvc2l0aW9uXHJcbiAgICAgICAgICBjb25zdCBvcGFjaXR5ID0gMC4zICsgMC43ICogKC1yb3RhdGVkLnogLyByYWRpdXMpXHJcblxyXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXHJcbiAgICAgICAgICBjdHguYXJjKHByb2plY3RlZC54LCBwcm9qZWN0ZWQueSwgcGFydGljbGVTaXplLCAwLCBNYXRoLlBJICogMilcclxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBgcmdiYSgxNTksIDIyMCwgMjU1LCAke29wYWNpdHl9KWBcclxuICAgICAgICAgIGN0eC5maWxsKClcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyBEcmF3IGNvbm5lY3Rpb25zIGJldHdlZW4gcG9pbnRzXHJcbiAgICAgIGNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24sIGlkeCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBvaW50QSA9IHByb2plY3RlZFBvaW50cy5maW5kKChwKSA9PiBwLmluZGV4ID09PSBjb25uZWN0aW9uWzBdKVxyXG4gICAgICAgIGNvbnN0IHBvaW50QiA9IHByb2plY3RlZFBvaW50cy5maW5kKChwKSA9PiBwLmluZGV4ID09PSBjb25uZWN0aW9uWzFdKVxyXG5cclxuICAgICAgICBpZiAocG9pbnRBICYmIHBvaW50QiAmJiBwb2ludEEueiA8IDAgJiYgcG9pbnRCLnogPCAwKSB7XHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgYW5pbWF0aW9uIHByb2dyZXNzIGZvciB0aGlzIGNvbm5lY3Rpb25cclxuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGFuaW1hdGlvblByb3BzLmNvbm5lY3Rpb25BbmltYXRpb25zW2lkeF1cclxuICAgICAgICAgIGFuaW1hdGlvbi5wcm9ncmVzcyArPSBhbmltYXRpb24uc3BlZWRcclxuICAgICAgICAgIGlmIChhbmltYXRpb24ucHJvZ3Jlc3MgPiAxKSBhbmltYXRpb24ucHJvZ3Jlc3MgPSAwXHJcblxyXG4gICAgICAgICAgLy8gRHJhdyB0aGUgY29ubmVjdGlvbiBsaW5lXHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRBLnByb2pYLCBwb2ludEEucHJvalkpXHJcbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50Qi5wcm9qWCwgcG9pbnRCLnByb2pZKVxyXG5cclxuICAgICAgICAgIC8vIExpbmUgb3BhY2l0eSBiYXNlZCBvbiBkZXB0aFxyXG4gICAgICAgICAgY29uc3QgYXZnRGVwdGggPSAocG9pbnRBLnogKyBwb2ludEIueikgLyAyXHJcbiAgICAgICAgICBjb25zdCBkZXB0aEZhY3RvciA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIC1hdmdEZXB0aCAvIHJhZGl1cykpXHJcbiAgICAgICAgICBjb25zdCBiYXNlT3BhY2l0eSA9IDAuMSArIDAuMyAqIGRlcHRoRmFjdG9yXHJcblxyXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoNzksIDE5NSwgMjQ3LCAke2Jhc2VPcGFjaXR5fSlgXHJcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gMVxyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpXHJcblxyXG4gICAgICAgICAgLy8gRHJhdyBhbmltYXRlZCBwdWxzZSBhbG9uZyB0aGUgY29ubmVjdGlvblxyXG4gICAgICAgICAgY29uc3QgcHVsc2VQb3MgPSBhbmltYXRpb24ucHJvZ3Jlc3NcclxuICAgICAgICAgIGNvbnN0IHB1bHNlWCA9IHBvaW50QS5wcm9qWCArIChwb2ludEIucHJvalggLSBwb2ludEEucHJvalgpICogcHVsc2VQb3NcclxuICAgICAgICAgIGNvbnN0IHB1bHNlWSA9IHBvaW50QS5wcm9qWSArIChwb2ludEIucHJvalkgLSBwb2ludEEucHJvalkpICogcHVsc2VQb3NcclxuXHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICAgIGN0eC5hcmMocHVsc2VYLCBwdWxzZVksIDIsIDAsIE1hdGguUEkgKiAyKVxyXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGByZ2JhKDc5LCAxOTUsIDI0NywgJHswLjcgKiBkZXB0aEZhY3Rvcn0pYFxyXG4gICAgICAgICAgY3R4LmZpbGwoKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIERyYXcgcG9pbnRzIG9uIHRoZSBnbG9iZVxyXG4gICAgICBwcm9qZWN0ZWRQb2ludHMuZm9yRWFjaCgocG9pbnQpID0+IHtcclxuICAgICAgICBpZiAocG9pbnQueiA8IDApIHtcclxuICAgICAgICAgIC8vIE9ubHkgZHJhdyBwb2ludHMgb24gdGhlIGZyb250IGhlbWlzcGhlcmVcclxuICAgICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IGFuaW1hdGlvblByb3BzLmhvdmVyUG9pbnQgJiYgYW5pbWF0aW9uUHJvcHMuaG92ZXJQb2ludC5pbmRleCA9PT0gcG9pbnQuaW5kZXhcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9pbnQgc2l6ZSBiYXNlZCBvbiBkZXB0aCBhbmQgaG92ZXIgc3RhdGVcclxuICAgICAgICAgIGNvbnN0IGJhc2VTaXplID0gMyAqIHBvaW50LnNpemVcclxuICAgICAgICAgIGNvbnN0IHNpemVNdWx0aXBsaWVyID0gaXNIb3ZlcmVkID8gMS41IDogMVxyXG4gICAgICAgICAgY29uc3QgcG9pbnRTaXplID0gYmFzZVNpemUgKiBwb2ludC5zY2FsZSAqIHNpemVNdWx0aXBsaWVyXHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG9wYWNpdHkgYmFzZWQgb24gZGVwdGhcclxuICAgICAgICAgIGNvbnN0IGRlcHRoRmFjdG9yID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgLXBvaW50LnogLyByYWRpdXMpKVxyXG4gICAgICAgICAgY29uc3QgYmFzZU9wYWNpdHkgPSAwLjUgKyAwLjUgKiBkZXB0aEZhY3RvclxyXG5cclxuICAgICAgICAgIC8vIFB1bHNlIGVmZmVjdFxyXG4gICAgICAgICAgY29uc3QgcHVsc2VTaXplID0gaXNIb3ZlcmVkXHJcbiAgICAgICAgICAgID8gMS4yICsgMC4zICogTWF0aC5zaW4oYW5pbWF0aW9uUHJvcHMudGltZSAqIDUpXHJcbiAgICAgICAgICAgIDogMSArIDAuMSAqIE1hdGguc2luKGFuaW1hdGlvblByb3BzLnRpbWUgKiAzKVxyXG5cclxuICAgICAgICAgIC8vIERyYXcgdGhlIHBvaW50IHdpdGggZ2xvdyBlZmZlY3RcclxuICAgICAgICAgIGRyYXdHbG93aW5nQ2lyY2xlKFxyXG4gICAgICAgICAgICBwb2ludC5wcm9qWCxcclxuICAgICAgICAgICAgcG9pbnQucHJvalksXHJcbiAgICAgICAgICAgIHBvaW50U2l6ZSAqIHB1bHNlU2l6ZSxcclxuICAgICAgICAgICAgaXNIb3ZlcmVkID8gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSlcIiA6IGByZ2JhKDc5LCAxOTUsIDI0NywgJHtiYXNlT3BhY2l0eX0pYCxcclxuICAgICAgICAgICAgaXNIb3ZlcmVkID8gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNClcIiA6IGByZ2JhKDc5LCAxOTUsIDI0NywgJHtiYXNlT3BhY2l0eSAqIDAuNX0pYCxcclxuICAgICAgICAgICAgcG9pbnRTaXplICogMixcclxuICAgICAgICAgIClcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyBEcmF3IGVxdWF0b3Igd2l0aCBzcGVjaWFsIGhpZ2hsaWdodFxyXG4gICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgY29uc3QgZXF1YXRvclBvaW50cyA9IFtdXHJcblxyXG4gICAgICBmb3IgKGxldCBsbmcgPSAtMTgwOyBsbmcgPD0gMTgwOyBsbmcgKz0gNSkge1xyXG4gICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gbGF0TG5nVG8zRCgwLCBsbmcsIHJhZGl1cylcclxuICAgICAgICBjb25zdCByb3RhdGVkID0gcm90YXRlUG9pbnQoeyB4LCB5LCB6IH0sIGludGVyYWN0aW9uUmVmLmN1cnJlbnQucm90YXRpb25YLCBpbnRlcmFjdGlvblJlZi5jdXJyZW50LnJvdGF0aW9uWSlcclxuXHJcbiAgICAgICAgaWYgKHJvdGF0ZWQueiA8IDApIHtcclxuICAgICAgICAgIC8vIE9ubHkgZHJhdyBwb2ludHMgb24gdGhlIGZyb250IGhlbWlzcGhlcmVcclxuICAgICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHByb2plY3Qocm90YXRlZCwgY2VudGVyWCwgY2VudGVyWSwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC56b29tKVxyXG4gICAgICAgICAgZXF1YXRvclBvaW50cy5wdXNoKHByb2plY3RlZClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlcXVhdG9yUG9pbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKClcclxuICAgICAgICBjdHgubW92ZVRvKGVxdWF0b3JQb2ludHNbMF0ueCwgZXF1YXRvclBvaW50c1swXS55KVxyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGVxdWF0b3JQb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGN0eC5saW5lVG8oZXF1YXRvclBvaW50c1tqXS54LCBlcXVhdG9yUG9pbnRzW2pdLnkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoNzksIDE5NSwgMjQ3LCAwLjUpXCJcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gMS41XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIG1vdXNlIGlzIGhvdmVyaW5nIG92ZXIgYW55IHBvaW50XHJcbiAgICAgIGlmIChhbmltYXRpb25Qcm9wcy5ob3ZlclBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbYW5pbWF0aW9uUHJvcHMuaG92ZXJQb2ludC5pbmRleF1cclxuXHJcbiAgICAgICAgLy8gRHJhdyB0b29sdGlwIHdpdGggY2l0eSBuYW1lXHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjE0cHggQXJpYWxcIlxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCJcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIlxyXG4gICAgICAgIGN0eC5maWxsVGV4dChwb2ludC5uYW1lLCBhbmltYXRpb25Qcm9wcy5ob3ZlclBvaW50LngsIGFuaW1hdGlvblByb3BzLmhvdmVyUG9pbnQueSAtIDIwKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTW91c2UgZXZlbnQgaGFuZGxlcnNcclxuICAgIGNvbnN0IGhhbmRsZU1vdXNlRG93biA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5pc01vdXNlRG93biA9IHRydWVcclxuICAgICAgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5sYXN0TW91c2VYID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0XHJcbiAgICAgIGludGVyYWN0aW9uUmVmLmN1cnJlbnQubGFzdE1vdXNlWSA9IGUuY2xpZW50WSAtIHJlY3QudG9wXHJcbiAgICAgIHNldElzSW50ZXJhY3RpbmcodHJ1ZSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcbiAgICAgIGNvbnN0IG1vdXNlWCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdFxyXG4gICAgICBjb25zdCBtb3VzZVkgPSBlLmNsaWVudFkgLSByZWN0LnRvcFxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgbW91c2UgaXMgaG92ZXJpbmcgb3ZlciBhbnkgcG9pbnRcclxuICAgICAgY29uc3QgY2VudGVyWCA9IHJlY3Qud2lkdGggLyAyXHJcbiAgICAgIGNvbnN0IGNlbnRlclkgPSByZWN0LmhlaWdodCAvIDJcclxuICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5taW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpICogMC4zNSAqIGludGVyYWN0aW9uUmVmLmN1cnJlbnQuem9vbVxyXG5cclxuICAgICAgbGV0IGhvdmVyZWRQb2ludCA9IG51bGxcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBhbGwgcG9pbnRzJyBwb3NpdGlvbnNcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IGxhdExuZ1RvM0QocG9pbnRzW2ldLmxhdCwgcG9pbnRzW2ldLmxuZywgcmFkaXVzKVxyXG4gICAgICAgIGNvbnN0IHJvdGF0ZWQgPSByb3RhdGVQb2ludCh7IHgsIHksIHogfSwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5yb3RhdGlvblgsIGludGVyYWN0aW9uUmVmLmN1cnJlbnQucm90YXRpb25ZKVxyXG5cclxuICAgICAgICBpZiAocm90YXRlZC56IDwgMCkge1xyXG4gICAgICAgICAgLy8gT25seSBjaGVjayBwb2ludHMgb24gdGhlIGZyb250IGhlbWlzcGhlcmVcclxuICAgICAgICAgIGNvbnN0IHByb2plY3RlZCA9IHByb2plY3Qocm90YXRlZCwgY2VudGVyWCwgY2VudGVyWSwgaW50ZXJhY3Rpb25SZWYuY3VycmVudC56b29tKVxyXG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3cobW91c2VYIC0gcHJvamVjdGVkLngsIDIpICsgTWF0aC5wb3cobW91c2VZIC0gcHJvamVjdGVkLnksIDIpKVxyXG5cclxuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDE1KSB7XHJcbiAgICAgICAgICAgIGhvdmVyZWRQb2ludCA9IHsgeDogcHJvamVjdGVkLngsIHk6IHByb2plY3RlZC55LCBpbmRleDogaSB9XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBhbmltYXRpb25Qcm9wcy5ob3ZlclBvaW50ID0gaG92ZXJlZFBvaW50XHJcblxyXG4gICAgICAvLyBIYW5kbGUgZHJhZ2dpbmcgZm9yIHJvdGF0aW9uXHJcbiAgICAgIGlmIChpbnRlcmFjdGlvblJlZi5jdXJyZW50LmlzTW91c2VEb3duKSB7XHJcbiAgICAgICAgY29uc3QgZGVsdGFYID0gbW91c2VYIC0gaW50ZXJhY3Rpb25SZWYuY3VycmVudC5sYXN0TW91c2VYXHJcbiAgICAgICAgY29uc3QgZGVsdGFZID0gbW91c2VZIC0gaW50ZXJhY3Rpb25SZWYuY3VycmVudC5sYXN0TW91c2VZXHJcblxyXG4gICAgICAgIGludGVyYWN0aW9uUmVmLmN1cnJlbnQucm90YXRpb25ZICs9IGRlbHRhWCAqIDAuMDFcclxuICAgICAgICBpbnRlcmFjdGlvblJlZi5jdXJyZW50LnJvdGF0aW9uWCArPSBkZWx0YVkgKiAwLjAxXHJcblxyXG4gICAgICAgIGludGVyYWN0aW9uUmVmLmN1cnJlbnQubGFzdE1vdXNlWCA9IG1vdXNlWFxyXG4gICAgICAgIGludGVyYWN0aW9uUmVmLmN1cnJlbnQubGFzdE1vdXNlWSA9IG1vdXNlWVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcclxuICAgICAgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5pc01vdXNlRG93biA9IGZhbHNlXHJcbiAgICAgIHNldElzSW50ZXJhY3RpbmcoZmFsc2UpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgaW50ZXJhY3Rpb25SZWYuY3VycmVudC5pc01vdXNlRG93biA9IGZhbHNlXHJcbiAgICAgIHNldElzSW50ZXJhY3RpbmcoZmFsc2UpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlV2hlZWwgPSAoZTogV2hlZWxFdmVudCkgPT4ge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgLy8gQWRqdXN0IHpvb20gbGV2ZWwgd2l0aCBtb3VzZSB3aGVlbFxyXG4gICAgICBjb25zdCB6b29tRGVsdGEgPSBlLmRlbHRhWSAqIC0wLjAwMVxyXG4gICAgICBpbnRlcmFjdGlvblJlZi5jdXJyZW50Lnpvb20gPSBNYXRoLm1heCgwLjUsIE1hdGgubWluKDIsIGludGVyYWN0aW9uUmVmLmN1cnJlbnQuem9vbSArIHpvb21EZWx0YSkpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgaGFuZGxlTW91c2VEb3duKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZU1vdXNlVXApXHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlTW91c2VMZWF2ZSlcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgaGFuZGxlV2hlZWwpXHJcblxyXG4gICAgLy8gQW5pbWF0aW9uIGxvb3BcclxuICAgIGxldCBhbmltYXRpb25JZDogbnVtYmVyXHJcbiAgICBjb25zdCBhbmltYXRlID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGRyYXdHbG9iZSh0aW1lc3RhbXApXHJcbiAgICAgIGFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXHJcbiAgICB9XHJcbiAgICBhbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxyXG5cclxuICAgIC8vIENsZWFudXAgb24gY29tcG9uZW50IHVubW91bnRcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHNldENhbnZhc0RpbWVuc2lvbnMpXHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZU1vdXNlRG93bilcclxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKVxyXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgaGFuZGxlTW91c2VVcClcclxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGhhbmRsZU1vdXNlTGVhdmUpXHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgaGFuZGxlV2hlZWwpXHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKVxyXG4gICAgfVxyXG4gIH0sIFtdKVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGNhbnZhc1xyXG4gICAgICByZWY9e2NhbnZhc1JlZn1cclxuICAgICAgY2xhc3NOYW1lPXtgZ2xvYmUtY2FudmFzIHctZnVsbCBoLWZ1bGwgYmxvY2sgJHtpc0ludGVyYWN0aW5nID8gXCJzaGFkb3ctWzBfMF8zMHB4X3JnYmEoNTksMTMwLDI0NiwwLjUpXVwiIDogXCJcIn1gfVxyXG4gICAgLz5cclxuICApXHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkdsb2JlVmlzdWFsaXphdGlvbiIsImNhbnZhc1JlZiIsImlzSW50ZXJhY3RpbmciLCJzZXRJc0ludGVyYWN0aW5nIiwiaW50ZXJhY3Rpb25SZWYiLCJpc01vdXNlRG93biIsImxhc3RNb3VzZVgiLCJsYXN0TW91c2VZIiwicm90YXRpb25TcGVlZFgiLCJyb3RhdGlvblNwZWVkWSIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsInpvb20iLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsInNldENhbnZhc0RpbWVuc2lvbnMiLCJjb250YWluZXIiLCJwYXJlbnRFbGVtZW50IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzdHlsZSIsInNjYWxlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBvaW50cyIsImxhdCIsImxuZyIsIm5hbWUiLCJzaXplIiwiY29ubmVjdGlvbnMiLCJhbmltYXRpb25Qcm9wcyIsInRpbWUiLCJwdWxzZVNwZWVkIiwiY29ubmVjdGlvbkFuaW1hdGlvbnMiLCJtYXAiLCJwcm9ncmVzcyIsIk1hdGgiLCJyYW5kb20iLCJzcGVlZCIsImhvdmVyUG9pbnQiLCJwYXJ0aWNsZVRpbWUiLCJudW1QYXJ0aWNsZXMiLCJwYXJ0aWNsZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJvZmZzZXQiLCJQSSIsImxhdExuZ1RvM0QiLCJyYWRpdXMiLCJwaGkiLCJ0aGV0YSIsIngiLCJzaW4iLCJjb3MiLCJ5IiwieiIsInJvdGF0ZVBvaW50IiwicG9pbnQiLCJjb3NZIiwic2luWSIsIngxIiwiejEiLCJjb3NYIiwic2luWCIsInkyIiwiejIiLCJwcm9qZWN0IiwiY2VudGVyWCIsImNlbnRlclkiLCJmb3YiLCJ2aWV3WiIsIm1heCIsImRlcHRoIiwiZHJhd0dsb3dpbmdDaXJjbGUiLCJjb2xvciIsImdsb3dDb2xvciIsImdsb3dTaXplIiwiZ3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsImZpbGxTdHlsZSIsImJlZ2luUGF0aCIsImFyYyIsImZpbGwiLCJkcmF3R2xvYmUiLCJ0aW1lc3RhbXAiLCJjbGVhclJlY3QiLCJiYXNlUmFkaXVzIiwibWluIiwiZ2xvd0dyYWRpZW50Iiwic3BoZXJlR3JhZGllbnQiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsInByb2plY3RlZFBvaW50cyIsImZvckVhY2giLCJpbmRleCIsInJvdGF0ZWQiLCJwcm9qZWN0ZWQiLCJwdXNoIiwicHJvalgiLCJwcm9qWSIsInNvcnQiLCJhIiwiYiIsIm51bUxhdExpbmVzIiwibnVtTG5nTGluZXMiLCJpIiwibW92ZVRvIiwiaiIsImxpbmVUbyIsInBhcnRpY2xlIiwib2Zmc2V0TG5nIiwicGFydGljbGVTaXplIiwib3BhY2l0eSIsImNvbm5lY3Rpb24iLCJpZHgiLCJwb2ludEEiLCJmaW5kIiwicCIsInBvaW50QiIsImFuaW1hdGlvbiIsImF2Z0RlcHRoIiwiZGVwdGhGYWN0b3IiLCJiYXNlT3BhY2l0eSIsInB1bHNlUG9zIiwicHVsc2VYIiwicHVsc2VZIiwiaXNIb3ZlcmVkIiwiYmFzZVNpemUiLCJzaXplTXVsdGlwbGllciIsInBvaW50U2l6ZSIsInB1bHNlU2l6ZSIsImVxdWF0b3JQb2ludHMiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFRleHQiLCJoYW5kbGVNb3VzZURvd24iLCJlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJsZWZ0IiwiY2xpZW50WSIsInRvcCIsImhhbmRsZU1vdXNlTW92ZSIsIm1vdXNlWCIsIm1vdXNlWSIsImhvdmVyZWRQb2ludCIsImRpc3RhbmNlIiwic3FydCIsInBvdyIsImRlbHRhWCIsImRlbHRhWSIsImhhbmRsZU1vdXNlVXAiLCJoYW5kbGVNb3VzZUxlYXZlIiwiaGFuZGxlV2hlZWwiLCJwcmV2ZW50RGVmYXVsdCIsInpvb21EZWx0YSIsImFuaW1hdGlvbklkIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlZiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/globe-visualization.tsx\n"));

/***/ })

});